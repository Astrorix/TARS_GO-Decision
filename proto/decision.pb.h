// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: decision.proto

#ifndef PROTOBUF_decision_2eproto__INCLUDED
#define PROTOBUF_decision_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace roborts_decision {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_decision_2eproto();
void protobuf_AssignDesc_decision_2eproto();
void protobuf_ShutdownFile_decision_2eproto();

class DecisionConfig;
class EscapeConstraint;
class MutualInfo;
class Point;
class PunishInfo;
class Referee;
class RobotInfo;
class SearchConstraint;
class Status;
class TopicName;
class WhirlVel;

enum Status_RunStatus {
  Status_RunStatus_CHASE = 1,
  Status_RunStatus_ESCAPE = 2,
  Status_RunStatus_BUFF = 3,
  Status_RunStatus_SHOOT = 4
};
bool Status_RunStatus_IsValid(int value);
const Status_RunStatus Status_RunStatus_RunStatus_MIN = Status_RunStatus_CHASE;
const Status_RunStatus Status_RunStatus_RunStatus_MAX = Status_RunStatus_SHOOT;
const int Status_RunStatus_RunStatus_ARRAYSIZE = Status_RunStatus_RunStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_RunStatus_descriptor();
inline const ::std::string& Status_RunStatus_Name(Status_RunStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_RunStatus_descriptor(), value);
}
inline bool Status_RunStatus_Parse(
    const ::std::string& name, Status_RunStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_RunStatus>(
    Status_RunStatus_descriptor(), name, value);
}
// ===================================================================

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  inline Point* New() const { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // optional float roll = 4;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 4;
  float roll() const;
  void set_roll(float value);

  // optional float pitch = 5;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 5;
  float pitch() const;
  void set_pitch(float value);

  // optional float yaw = 6;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 6;
  float yaw() const;
  void set_yaw(float value);

  // @@protoc_insertion_point(class_scope:roborts_decision.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float roll_;
  float pitch_;
  float yaw_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class EscapeConstraint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.EscapeConstraint) */ {
 public:
  EscapeConstraint();
  virtual ~EscapeConstraint();

  EscapeConstraint(const EscapeConstraint& from);

  inline EscapeConstraint& operator=(const EscapeConstraint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EscapeConstraint& default_instance();

  void Swap(EscapeConstraint* other);

  // implements Message ----------------------------------------------

  inline EscapeConstraint* New() const { return New(NULL); }

  EscapeConstraint* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EscapeConstraint& from);
  void MergeFrom(const EscapeConstraint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EscapeConstraint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float left_x_limit = 1;
  bool has_left_x_limit() const;
  void clear_left_x_limit();
  static const int kLeftXLimitFieldNumber = 1;
  float left_x_limit() const;
  void set_left_x_limit(float value);

  // optional float right_x_limit = 2;
  bool has_right_x_limit() const;
  void clear_right_x_limit();
  static const int kRightXLimitFieldNumber = 2;
  float right_x_limit() const;
  void set_right_x_limit(float value);

  // optional float robot_x_limit = 3;
  bool has_robot_x_limit() const;
  void clear_robot_x_limit();
  static const int kRobotXLimitFieldNumber = 3;
  float robot_x_limit() const;
  void set_robot_x_limit(float value);

  // optional float left_random_min_x = 4;
  bool has_left_random_min_x() const;
  void clear_left_random_min_x();
  static const int kLeftRandomMinXFieldNumber = 4;
  float left_random_min_x() const;
  void set_left_random_min_x(float value);

  // optional float left_random_max_x = 5;
  bool has_left_random_max_x() const;
  void clear_left_random_max_x();
  static const int kLeftRandomMaxXFieldNumber = 5;
  float left_random_max_x() const;
  void set_left_random_max_x(float value);

  // optional float right_random_min_x = 6;
  bool has_right_random_min_x() const;
  void clear_right_random_min_x();
  static const int kRightRandomMinXFieldNumber = 6;
  float right_random_min_x() const;
  void set_right_random_min_x(float value);

  // optional float right_random_max_x = 7;
  bool has_right_random_max_x() const;
  void clear_right_random_max_x();
  static const int kRightRandomMaxXFieldNumber = 7;
  float right_random_max_x() const;
  void set_right_random_max_x(float value);

  // @@protoc_insertion_point(class_scope:roborts_decision.EscapeConstraint)
 private:
  inline void set_has_left_x_limit();
  inline void clear_has_left_x_limit();
  inline void set_has_right_x_limit();
  inline void clear_has_right_x_limit();
  inline void set_has_robot_x_limit();
  inline void clear_has_robot_x_limit();
  inline void set_has_left_random_min_x();
  inline void clear_has_left_random_min_x();
  inline void set_has_left_random_max_x();
  inline void clear_has_left_random_max_x();
  inline void set_has_right_random_min_x();
  inline void clear_has_right_random_min_x();
  inline void set_has_right_random_max_x();
  inline void clear_has_right_random_max_x();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float left_x_limit_;
  float right_x_limit_;
  float robot_x_limit_;
  float left_random_min_x_;
  float left_random_max_x_;
  float right_random_min_x_;
  float right_random_max_x_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static EscapeConstraint* default_instance_;
};
// -------------------------------------------------------------------

class SearchConstraint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.SearchConstraint) */ {
 public:
  SearchConstraint();
  virtual ~SearchConstraint();

  SearchConstraint(const SearchConstraint& from);

  inline SearchConstraint& operator=(const SearchConstraint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchConstraint& default_instance();

  void Swap(SearchConstraint* other);

  // implements Message ----------------------------------------------

  inline SearchConstraint* New() const { return New(NULL); }

  SearchConstraint* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchConstraint& from);
  void MergeFrom(const SearchConstraint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SearchConstraint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x_limit = 1;
  bool has_x_limit() const;
  void clear_x_limit();
  static const int kXLimitFieldNumber = 1;
  float x_limit() const;
  void set_x_limit(float value);

  // optional float y_limit = 2;
  bool has_y_limit() const;
  void clear_y_limit();
  static const int kYLimitFieldNumber = 2;
  float y_limit() const;
  void set_y_limit(float value);

  // @@protoc_insertion_point(class_scope:roborts_decision.SearchConstraint)
 private:
  inline void set_has_x_limit();
  inline void clear_has_x_limit();
  inline void set_has_y_limit();
  inline void clear_has_y_limit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_limit_;
  float y_limit_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static SearchConstraint* default_instance_;
};
// -------------------------------------------------------------------

class WhirlVel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.WhirlVel) */ {
 public:
  WhirlVel();
  virtual ~WhirlVel();

  WhirlVel(const WhirlVel& from);

  inline WhirlVel& operator=(const WhirlVel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WhirlVel& default_instance();

  void Swap(WhirlVel* other);

  // implements Message ----------------------------------------------

  inline WhirlVel* New() const { return New(NULL); }

  WhirlVel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WhirlVel& from);
  void MergeFrom(const WhirlVel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WhirlVel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float angle_x_vel = 1;
  bool has_angle_x_vel() const;
  void clear_angle_x_vel();
  static const int kAngleXVelFieldNumber = 1;
  float angle_x_vel() const;
  void set_angle_x_vel(float value);

  // optional float angle_y_vel = 2;
  bool has_angle_y_vel() const;
  void clear_angle_y_vel();
  static const int kAngleYVelFieldNumber = 2;
  float angle_y_vel() const;
  void set_angle_y_vel(float value);

  // optional float angle_z_vel = 3;
  bool has_angle_z_vel() const;
  void clear_angle_z_vel();
  static const int kAngleZVelFieldNumber = 3;
  float angle_z_vel() const;
  void set_angle_z_vel(float value);

  // @@protoc_insertion_point(class_scope:roborts_decision.WhirlVel)
 private:
  inline void set_has_angle_x_vel();
  inline void clear_has_angle_x_vel();
  inline void set_has_angle_y_vel();
  inline void clear_has_angle_y_vel();
  inline void set_has_angle_z_vel();
  inline void clear_has_angle_z_vel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float angle_x_vel_;
  float angle_y_vel_;
  float angle_z_vel_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static WhirlVel* default_instance_;
};
// -------------------------------------------------------------------

class Referee : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.Referee) */ {
 public:
  Referee();
  virtual ~Referee();

  Referee(const Referee& from);

  inline Referee& operator=(const Referee& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Referee& default_instance();

  void Swap(Referee* other);

  // implements Message ----------------------------------------------

  inline Referee* New() const { return New(NULL); }

  Referee* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Referee& from);
  void MergeFrom(const Referee& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Referee* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string game_result = 2;
  bool has_game_result() const;
  void clear_game_result();
  static const int kGameResultFieldNumber = 2;
  const ::std::string& game_result() const;
  void set_game_result(const ::std::string& value);
  void set_game_result(const char* value);
  void set_game_result(const char* value, size_t size);
  ::std::string* mutable_game_result();
  ::std::string* release_game_result();
  void set_allocated_game_result(::std::string* game_result);

  // optional string game_status = 1;
  bool has_game_status() const;
  void clear_game_status();
  static const int kGameStatusFieldNumber = 1;
  const ::std::string& game_status() const;
  void set_game_status(const ::std::string& value);
  void set_game_status(const char* value);
  void set_game_status(const char* value, size_t size);
  ::std::string* mutable_game_status();
  ::std::string* release_game_status();
  void set_allocated_game_status(::std::string* game_status);

  // optional string game_survivor = 3;
  bool has_game_survivor() const;
  void clear_game_survivor();
  static const int kGameSurvivorFieldNumber = 3;
  const ::std::string& game_survivor() const;
  void set_game_survivor(const ::std::string& value);
  void set_game_survivor(const char* value);
  void set_game_survivor(const char* value, size_t size);
  ::std::string* mutable_game_survivor();
  ::std::string* release_game_survivor();
  void set_allocated_game_survivor(::std::string* game_survivor);

  // optional string robort_status = 4;
  bool has_robort_status() const;
  void clear_robort_status();
  static const int kRobortStatusFieldNumber = 4;
  const ::std::string& robort_status() const;
  void set_robort_status(const ::std::string& value);
  void set_robort_status(const char* value);
  void set_robort_status(const char* value, size_t size);
  ::std::string* mutable_robort_status();
  ::std::string* release_robort_status();
  void set_allocated_robort_status(::std::string* robort_status);

  // optional string robort_heat = 5;
  bool has_robort_heat() const;
  void clear_robort_heat();
  static const int kRobortHeatFieldNumber = 5;
  const ::std::string& robort_heat() const;
  void set_robort_heat(const ::std::string& value);
  void set_robort_heat(const char* value);
  void set_robort_heat(const char* value, size_t size);
  ::std::string* mutable_robort_heat();
  ::std::string* release_robort_heat();
  void set_allocated_robort_heat(::std::string* robort_heat);

  // optional string robort_bonus = 6;
  bool has_robort_bonus() const;
  void clear_robort_bonus();
  static const int kRobortBonusFieldNumber = 6;
  const ::std::string& robort_bonus() const;
  void set_robort_bonus(const ::std::string& value);
  void set_robort_bonus(const char* value);
  void set_robort_bonus(const char* value, size_t size);
  ::std::string* mutable_robort_bonus();
  ::std::string* release_robort_bonus();
  void set_allocated_robort_bonus(::std::string* robort_bonus);

  // optional string robort_damage = 7;
  bool has_robort_damage() const;
  void clear_robort_damage();
  static const int kRobortDamageFieldNumber = 7;
  const ::std::string& robort_damage() const;
  void set_robort_damage(const ::std::string& value);
  void set_robort_damage(const char* value);
  void set_robort_damage(const char* value, size_t size);
  ::std::string* mutable_robort_damage();
  ::std::string* release_robort_damage();
  void set_allocated_robort_damage(::std::string* robort_damage);

  // optional string robort_shoot = 8;
  bool has_robort_shoot() const;
  void clear_robort_shoot();
  static const int kRobortShootFieldNumber = 8;
  const ::std::string& robort_shoot() const;
  void set_robort_shoot(const ::std::string& value);
  void set_robort_shoot(const char* value);
  void set_robort_shoot(const char* value, size_t size);
  ::std::string* mutable_robort_shoot();
  ::std::string* release_robort_shoot();
  void set_allocated_robort_shoot(::std::string* robort_shoot);

  // optional string bonus_status = 9;
  bool has_bonus_status() const;
  void clear_bonus_status();
  static const int kBonusStatusFieldNumber = 9;
  const ::std::string& bonus_status() const;
  void set_bonus_status(const ::std::string& value);
  void set_bonus_status(const char* value);
  void set_bonus_status(const char* value, size_t size);
  ::std::string* mutable_bonus_status();
  ::std::string* release_bonus_status();
  void set_allocated_bonus_status(::std::string* bonus_status);

  // optional string local_name = 10;
  bool has_local_name() const;
  void clear_local_name();
  static const int kLocalNameFieldNumber = 10;
  const ::std::string& local_name() const;
  void set_local_name(const ::std::string& value);
  void set_local_name(const char* value);
  void set_local_name(const char* value, size_t size);
  ::std::string* mutable_local_name();
  ::std::string* release_local_name();
  void set_allocated_local_name(::std::string* local_name);

  // optional string remote_name = 11;
  bool has_remote_name() const;
  void clear_remote_name();
  static const int kRemoteNameFieldNumber = 11;
  const ::std::string& remote_name() const;
  void set_remote_name(const ::std::string& value);
  void set_remote_name(const char* value);
  void set_remote_name(const char* value, size_t size);
  ::std::string* mutable_remote_name();
  ::std::string* release_remote_name();
  void set_allocated_remote_name(::std::string* remote_name);

  // @@protoc_insertion_point(class_scope:roborts_decision.Referee)
 private:
  inline void set_has_game_result();
  inline void clear_has_game_result();
  inline void set_has_game_status();
  inline void clear_has_game_status();
  inline void set_has_game_survivor();
  inline void clear_has_game_survivor();
  inline void set_has_robort_status();
  inline void clear_has_robort_status();
  inline void set_has_robort_heat();
  inline void clear_has_robort_heat();
  inline void set_has_robort_bonus();
  inline void clear_has_robort_bonus();
  inline void set_has_robort_damage();
  inline void clear_has_robort_damage();
  inline void set_has_robort_shoot();
  inline void clear_has_robort_shoot();
  inline void set_has_bonus_status();
  inline void clear_has_bonus_status();
  inline void set_has_local_name();
  inline void clear_has_local_name();
  inline void set_has_remote_name();
  inline void clear_has_remote_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr game_result_;
  ::google::protobuf::internal::ArenaStringPtr game_status_;
  ::google::protobuf::internal::ArenaStringPtr game_survivor_;
  ::google::protobuf::internal::ArenaStringPtr robort_status_;
  ::google::protobuf::internal::ArenaStringPtr robort_heat_;
  ::google::protobuf::internal::ArenaStringPtr robort_bonus_;
  ::google::protobuf::internal::ArenaStringPtr robort_damage_;
  ::google::protobuf::internal::ArenaStringPtr robort_shoot_;
  ::google::protobuf::internal::ArenaStringPtr bonus_status_;
  ::google::protobuf::internal::ArenaStringPtr local_name_;
  ::google::protobuf::internal::ArenaStringPtr remote_name_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static Referee* default_instance_;
};
// -------------------------------------------------------------------

class TopicName : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.TopicName) */ {
 public:
  TopicName();
  virtual ~TopicName();

  TopicName(const TopicName& from);

  inline TopicName& operator=(const TopicName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicName& default_instance();

  void Swap(TopicName* other);

  // implements Message ----------------------------------------------

  inline TopicName* New() const { return New(NULL); }

  TopicName* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicName& from);
  void MergeFrom(const TopicName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TopicName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topic = 1;
  int topic_size() const;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic(int index) const;
  ::std::string* mutable_topic(int index);
  void set_topic(int index, const ::std::string& value);
  void set_topic(int index, const char* value);
  void set_topic(int index, const char* value, size_t size);
  ::std::string* add_topic();
  void add_topic(const ::std::string& value);
  void add_topic(const char* value);
  void add_topic(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& topic() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic();

  // @@protoc_insertion_point(class_scope:roborts_decision.TopicName)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static TopicName* default_instance_;
};
// -------------------------------------------------------------------

class DecisionConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.DecisionConfig) */ {
 public:
  DecisionConfig();
  virtual ~DecisionConfig();

  DecisionConfig(const DecisionConfig& from);

  inline DecisionConfig& operator=(const DecisionConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecisionConfig& default_instance();

  void Swap(DecisionConfig* other);

  // implements Message ----------------------------------------------

  inline DecisionConfig* New() const { return New(NULL); }

  DecisionConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecisionConfig& from);
  void MergeFrom(const DecisionConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecisionConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .roborts_decision.Point point = 1;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::roborts_decision::Point& point(int index) const;
  ::roborts_decision::Point* mutable_point(int index);
  ::roborts_decision::Point* add_point();
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
      mutable_point();
  const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
      point() const;

  // optional bool simulate = 2 [default = false];
  bool has_simulate() const;
  void clear_simulate();
  static const int kSimulateFieldNumber = 2;
  bool simulate() const;
  void set_simulate(bool value);

  // optional bool master = 3 [default = false];
  bool has_master() const;
  void clear_master();
  static const int kMasterFieldNumber = 3;
  bool master() const;
  void set_master(bool value);

  // repeated .roborts_decision.Point escape = 4;
  int escape_size() const;
  void clear_escape();
  static const int kEscapeFieldNumber = 4;
  const ::roborts_decision::Point& escape(int index) const;
  ::roborts_decision::Point* mutable_escape(int index);
  ::roborts_decision::Point* add_escape();
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
      mutable_escape();
  const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
      escape() const;

  // repeated .roborts_decision.Point buff_point = 5;
  int buff_point_size() const;
  void clear_buff_point();
  static const int kBuffPointFieldNumber = 5;
  const ::roborts_decision::Point& buff_point(int index) const;
  ::roborts_decision::Point* mutable_buff_point(int index);
  ::roborts_decision::Point* add_buff_point();
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
      mutable_buff_point();
  const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
      buff_point() const;

  // repeated .roborts_decision.Point search_path = 6;
  int search_path_size() const;
  void clear_search_path();
  static const int kSearchPathFieldNumber = 6;
  const ::roborts_decision::Point& search_path(int index) const;
  ::roborts_decision::Point* mutable_search_path(int index);
  ::roborts_decision::Point* add_search_path();
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
      mutable_search_path();
  const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
      search_path() const;

  // repeated .roborts_decision.Point e_search_path = 7;
  int e_search_path_size() const;
  void clear_e_search_path();
  static const int kESearchPathFieldNumber = 7;
  const ::roborts_decision::Point& e_search_path(int index) const;
  ::roborts_decision::Point* mutable_e_search_path(int index);
  ::roborts_decision::Point* add_e_search_path();
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
      mutable_e_search_path();
  const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
      e_search_path() const;

  // repeated .roborts_decision.Point c_search_path = 8;
  int c_search_path_size() const;
  void clear_c_search_path();
  static const int kCSearchPathFieldNumber = 8;
  const ::roborts_decision::Point& c_search_path(int index) const;
  ::roborts_decision::Point* mutable_c_search_path(int index);
  ::roborts_decision::Point* add_c_search_path();
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
      mutable_c_search_path();
  const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
      c_search_path() const;

  // optional .roborts_decision.WhirlVel whirl_vel = 9;
  bool has_whirl_vel() const;
  void clear_whirl_vel();
  static const int kWhirlVelFieldNumber = 9;
  const ::roborts_decision::WhirlVel& whirl_vel() const;
  ::roborts_decision::WhirlVel* mutable_whirl_vel();
  ::roborts_decision::WhirlVel* release_whirl_vel();
  void set_allocated_whirl_vel(::roborts_decision::WhirlVel* whirl_vel);

  // repeated .roborts_decision.Point auxe_bot = 10;
  int auxe_bot_size() const;
  void clear_auxe_bot();
  static const int kAuxeBotFieldNumber = 10;
  const ::roborts_decision::Point& auxe_bot(int index) const;
  ::roborts_decision::Point* mutable_auxe_bot(int index);
  ::roborts_decision::Point* add_auxe_bot();
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
      mutable_auxe_bot();
  const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
      auxe_bot() const;

  // repeated .roborts_decision.Point master_bot = 11;
  int master_bot_size() const;
  void clear_master_bot();
  static const int kMasterBotFieldNumber = 11;
  const ::roborts_decision::Point& master_bot(int index) const;
  ::roborts_decision::Point* mutable_master_bot(int index);
  ::roborts_decision::Point* add_master_bot();
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
      mutable_master_bot();
  const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
      master_bot() const;

  // optional .roborts_decision.Point wing_bot_task_point = 12;
  bool has_wing_bot_task_point() const;
  void clear_wing_bot_task_point();
  static const int kWingBotTaskPointFieldNumber = 12;
  const ::roborts_decision::Point& wing_bot_task_point() const;
  ::roborts_decision::Point* mutable_wing_bot_task_point();
  ::roborts_decision::Point* release_wing_bot_task_point();
  void set_allocated_wing_bot_task_point(::roborts_decision::Point* wing_bot_task_point);

  // repeated .roborts_decision.Point wait_point = 13;
  int wait_point_size() const;
  void clear_wait_point();
  static const int kWaitPointFieldNumber = 13;
  const ::roborts_decision::Point& wait_point(int index) const;
  ::roborts_decision::Point* mutable_wait_point(int index);
  ::roborts_decision::Point* add_wait_point();
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
      mutable_wait_point();
  const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
      wait_point() const;

  // repeated float square_x = 14;
  int square_x_size() const;
  void clear_square_x();
  static const int kSquareXFieldNumber = 14;
  float square_x(int index) const;
  void set_square_x(int index, float value);
  void add_square_x(float value);
  const ::google::protobuf::RepeatedField< float >&
      square_x() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_square_x();

  // repeated float square_y = 15;
  int square_y_size() const;
  void clear_square_y();
  static const int kSquareYFieldNumber = 15;
  float square_y(int index) const;
  void set_square_y(int index, float value);
  void add_square_y(float value);
  const ::google::protobuf::RepeatedField< float >&
      square_y() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_square_y();

  // @@protoc_insertion_point(class_scope:roborts_decision.DecisionConfig)
 private:
  inline void set_has_simulate();
  inline void clear_has_simulate();
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_whirl_vel();
  inline void clear_has_whirl_vel();
  inline void set_has_wing_bot_task_point();
  inline void clear_has_wing_bot_task_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point > point_;
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point > escape_;
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point > buff_point_;
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point > search_path_;
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point > e_search_path_;
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point > c_search_path_;
  ::roborts_decision::WhirlVel* whirl_vel_;
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point > auxe_bot_;
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point > master_bot_;
  ::roborts_decision::Point* wing_bot_task_point_;
  ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point > wait_point_;
  ::google::protobuf::RepeatedField< float > square_x_;
  ::google::protobuf::RepeatedField< float > square_y_;
  bool simulate_;
  bool master_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static DecisionConfig* default_instance_;
};
// -------------------------------------------------------------------

class RobotInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.RobotInfo) */ {
 public:
  RobotInfo();
  virtual ~RobotInfo();

  RobotInfo(const RobotInfo& from);

  inline RobotInfo& operator=(const RobotInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotInfo& default_instance();

  void Swap(RobotInfo* other);

  // implements Message ----------------------------------------------

  inline RobotInfo* New() const { return New(NULL); }

  RobotInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotInfo& from);
  void MergeFrom(const RobotInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RobotInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 hp = 1;
  bool has_hp() const;
  void clear_hp();
  static const int kHpFieldNumber = 1;
  ::google::protobuf::int32 hp() const;
  void set_hp(::google::protobuf::int32 value);

  // optional int32 heat = 2;
  bool has_heat() const;
  void clear_heat();
  static const int kHeatFieldNumber = 2;
  ::google::protobuf::int32 heat() const;
  void set_heat(::google::protobuf::int32 value);

  // optional int32 bullets = 3;
  bool has_bullets() const;
  void clear_bullets();
  static const int kBulletsFieldNumber = 3;
  ::google::protobuf::int32 bullets() const;
  void set_bullets(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:roborts_decision.RobotInfo)
 private:
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_heat();
  inline void clear_has_heat();
  inline void set_has_bullets();
  inline void clear_has_bullets();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 heat_;
  ::google::protobuf::int32 bullets_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static RobotInfo* default_instance_;
};
// -------------------------------------------------------------------

class PunishInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.PunishInfo) */ {
 public:
  PunishInfo();
  virtual ~PunishInfo();

  PunishInfo(const PunishInfo& from);

  inline PunishInfo& operator=(const PunishInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PunishInfo& default_instance();

  void Swap(PunishInfo* other);

  // implements Message ----------------------------------------------

  inline PunishInfo* New() const { return New(NULL); }

  PunishInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PunishInfo& from);
  void MergeFrom(const PunishInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PunishInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool on_gimbal = 1;
  bool has_on_gimbal() const;
  void clear_on_gimbal();
  static const int kOnGimbalFieldNumber = 1;
  bool on_gimbal() const;
  void set_on_gimbal(bool value);

  // optional bool on_chassis = 2;
  bool has_on_chassis() const;
  void clear_on_chassis();
  static const int kOnChassisFieldNumber = 2;
  bool on_chassis() const;
  void set_on_chassis(bool value);

  // @@protoc_insertion_point(class_scope:roborts_decision.PunishInfo)
 private:
  inline void set_has_on_gimbal();
  inline void clear_has_on_gimbal();
  inline void set_has_on_chassis();
  inline void clear_has_on_chassis();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool on_gimbal_;
  bool on_chassis_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static PunishInfo* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  inline Status* New() const { return New(NULL); }

  Status* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Status_RunStatus RunStatus;
  static const RunStatus CHASE =
    Status_RunStatus_CHASE;
  static const RunStatus ESCAPE =
    Status_RunStatus_ESCAPE;
  static const RunStatus BUFF =
    Status_RunStatus_BUFF;
  static const RunStatus SHOOT =
    Status_RunStatus_SHOOT;
  static inline bool RunStatus_IsValid(int value) {
    return Status_RunStatus_IsValid(value);
  }
  static const RunStatus RunStatus_MIN =
    Status_RunStatus_RunStatus_MIN;
  static const RunStatus RunStatus_MAX =
    Status_RunStatus_RunStatus_MAX;
  static const int RunStatus_ARRAYSIZE =
    Status_RunStatus_RunStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RunStatus_descriptor() {
    return Status_RunStatus_descriptor();
  }
  static inline const ::std::string& RunStatus_Name(RunStatus value) {
    return Status_RunStatus_Name(value);
  }
  static inline bool RunStatus_Parse(const ::std::string& name,
      RunStatus* value) {
    return Status_RunStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bool is_running = 1;
  bool has_is_running() const;
  void clear_is_running();
  static const int kIsRunningFieldNumber = 1;
  bool is_running() const;
  void set_is_running(bool value);

  // optional .roborts_decision.Status.RunStatus status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::roborts_decision::Status_RunStatus status() const;
  void set_status(::roborts_decision::Status_RunStatus value);

  // optional .roborts_decision.Point position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::roborts_decision::Point& position() const;
  ::roborts_decision::Point* mutable_position();
  ::roborts_decision::Point* release_position();
  void set_allocated_position(::roborts_decision::Point* position);

  // @@protoc_insertion_point(class_scope:roborts_decision.Status)
 private:
  inline void set_has_is_running();
  inline void clear_has_is_running();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool is_running_;
  int status_;
  ::roborts_decision::Point* position_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class MutualInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_decision.MutualInfo) */ {
 public:
  MutualInfo();
  virtual ~MutualInfo();

  MutualInfo(const MutualInfo& from);

  inline MutualInfo& operator=(const MutualInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MutualInfo& default_instance();

  void Swap(MutualInfo* other);

  // implements Message ----------------------------------------------

  inline MutualInfo* New() const { return New(NULL); }

  MutualInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MutualInfo& from);
  void MergeFrom(const MutualInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MutualInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .roborts_decision.RobotInfo robort_info = 1;
  bool has_robort_info() const;
  void clear_robort_info();
  static const int kRobortInfoFieldNumber = 1;
  const ::roborts_decision::RobotInfo& robort_info() const;
  ::roborts_decision::RobotInfo* mutable_robort_info();
  ::roborts_decision::RobotInfo* release_robort_info();
  void set_allocated_robort_info(::roborts_decision::RobotInfo* robort_info);

  // optional .roborts_decision.PunishInfo punish = 2;
  bool has_punish() const;
  void clear_punish();
  static const int kPunishFieldNumber = 2;
  const ::roborts_decision::PunishInfo& punish() const;
  ::roborts_decision::PunishInfo* mutable_punish();
  ::roborts_decision::PunishInfo* release_punish();
  void set_allocated_punish(::roborts_decision::PunishInfo* punish);

  // optional .roborts_decision.Status status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  const ::roborts_decision::Status& status() const;
  ::roborts_decision::Status* mutable_status();
  ::roborts_decision::Status* release_status();
  void set_allocated_status(::roborts_decision::Status* status);

  // @@protoc_insertion_point(class_scope:roborts_decision.MutualInfo)
 private:
  inline void set_has_robort_info();
  inline void clear_has_robort_info();
  inline void set_has_punish();
  inline void clear_has_punish();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::roborts_decision::RobotInfo* robort_info_;
  ::roborts_decision::PunishInfo* punish_;
  ::roborts_decision::Status* status_;
  friend void  protobuf_AddDesc_decision_2eproto();
  friend void protobuf_AssignDesc_decision_2eproto();
  friend void protobuf_ShutdownFile_decision_2eproto();

  void InitAsDefaultInstance();
  static MutualInfo* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Point

// optional float x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Point.x)
  return x_;
}
inline void Point::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.Point.x)
}

// optional float y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Point.y)
  return y_;
}
inline void Point::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.Point.y)
}

// optional float z = 3;
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Point::z() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Point.z)
  return z_;
}
inline void Point::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.Point.z)
}

// optional float roll = 4;
inline bool Point::has_roll() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Point::set_has_roll() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Point::clear_has_roll() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Point::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float Point::roll() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Point.roll)
  return roll_;
}
inline void Point::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.Point.roll)
}

// optional float pitch = 5;
inline bool Point::has_pitch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Point::set_has_pitch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Point::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Point::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float Point::pitch() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Point.pitch)
  return pitch_;
}
inline void Point::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.Point.pitch)
}

// optional float yaw = 6;
inline bool Point::has_yaw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Point::set_has_yaw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Point::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Point::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float Point::yaw() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Point.yaw)
  return yaw_;
}
inline void Point::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.Point.yaw)
}

// -------------------------------------------------------------------

// EscapeConstraint

// optional float left_x_limit = 1;
inline bool EscapeConstraint::has_left_x_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EscapeConstraint::set_has_left_x_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EscapeConstraint::clear_has_left_x_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EscapeConstraint::clear_left_x_limit() {
  left_x_limit_ = 0;
  clear_has_left_x_limit();
}
inline float EscapeConstraint::left_x_limit() const {
  // @@protoc_insertion_point(field_get:roborts_decision.EscapeConstraint.left_x_limit)
  return left_x_limit_;
}
inline void EscapeConstraint::set_left_x_limit(float value) {
  set_has_left_x_limit();
  left_x_limit_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.EscapeConstraint.left_x_limit)
}

// optional float right_x_limit = 2;
inline bool EscapeConstraint::has_right_x_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EscapeConstraint::set_has_right_x_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EscapeConstraint::clear_has_right_x_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EscapeConstraint::clear_right_x_limit() {
  right_x_limit_ = 0;
  clear_has_right_x_limit();
}
inline float EscapeConstraint::right_x_limit() const {
  // @@protoc_insertion_point(field_get:roborts_decision.EscapeConstraint.right_x_limit)
  return right_x_limit_;
}
inline void EscapeConstraint::set_right_x_limit(float value) {
  set_has_right_x_limit();
  right_x_limit_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.EscapeConstraint.right_x_limit)
}

// optional float robot_x_limit = 3;
inline bool EscapeConstraint::has_robot_x_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EscapeConstraint::set_has_robot_x_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EscapeConstraint::clear_has_robot_x_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EscapeConstraint::clear_robot_x_limit() {
  robot_x_limit_ = 0;
  clear_has_robot_x_limit();
}
inline float EscapeConstraint::robot_x_limit() const {
  // @@protoc_insertion_point(field_get:roborts_decision.EscapeConstraint.robot_x_limit)
  return robot_x_limit_;
}
inline void EscapeConstraint::set_robot_x_limit(float value) {
  set_has_robot_x_limit();
  robot_x_limit_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.EscapeConstraint.robot_x_limit)
}

// optional float left_random_min_x = 4;
inline bool EscapeConstraint::has_left_random_min_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EscapeConstraint::set_has_left_random_min_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EscapeConstraint::clear_has_left_random_min_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EscapeConstraint::clear_left_random_min_x() {
  left_random_min_x_ = 0;
  clear_has_left_random_min_x();
}
inline float EscapeConstraint::left_random_min_x() const {
  // @@protoc_insertion_point(field_get:roborts_decision.EscapeConstraint.left_random_min_x)
  return left_random_min_x_;
}
inline void EscapeConstraint::set_left_random_min_x(float value) {
  set_has_left_random_min_x();
  left_random_min_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.EscapeConstraint.left_random_min_x)
}

// optional float left_random_max_x = 5;
inline bool EscapeConstraint::has_left_random_max_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EscapeConstraint::set_has_left_random_max_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EscapeConstraint::clear_has_left_random_max_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EscapeConstraint::clear_left_random_max_x() {
  left_random_max_x_ = 0;
  clear_has_left_random_max_x();
}
inline float EscapeConstraint::left_random_max_x() const {
  // @@protoc_insertion_point(field_get:roborts_decision.EscapeConstraint.left_random_max_x)
  return left_random_max_x_;
}
inline void EscapeConstraint::set_left_random_max_x(float value) {
  set_has_left_random_max_x();
  left_random_max_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.EscapeConstraint.left_random_max_x)
}

// optional float right_random_min_x = 6;
inline bool EscapeConstraint::has_right_random_min_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EscapeConstraint::set_has_right_random_min_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EscapeConstraint::clear_has_right_random_min_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EscapeConstraint::clear_right_random_min_x() {
  right_random_min_x_ = 0;
  clear_has_right_random_min_x();
}
inline float EscapeConstraint::right_random_min_x() const {
  // @@protoc_insertion_point(field_get:roborts_decision.EscapeConstraint.right_random_min_x)
  return right_random_min_x_;
}
inline void EscapeConstraint::set_right_random_min_x(float value) {
  set_has_right_random_min_x();
  right_random_min_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.EscapeConstraint.right_random_min_x)
}

// optional float right_random_max_x = 7;
inline bool EscapeConstraint::has_right_random_max_x() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EscapeConstraint::set_has_right_random_max_x() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EscapeConstraint::clear_has_right_random_max_x() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EscapeConstraint::clear_right_random_max_x() {
  right_random_max_x_ = 0;
  clear_has_right_random_max_x();
}
inline float EscapeConstraint::right_random_max_x() const {
  // @@protoc_insertion_point(field_get:roborts_decision.EscapeConstraint.right_random_max_x)
  return right_random_max_x_;
}
inline void EscapeConstraint::set_right_random_max_x(float value) {
  set_has_right_random_max_x();
  right_random_max_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.EscapeConstraint.right_random_max_x)
}

// -------------------------------------------------------------------

// SearchConstraint

// optional float x_limit = 1;
inline bool SearchConstraint::has_x_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchConstraint::set_has_x_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchConstraint::clear_has_x_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchConstraint::clear_x_limit() {
  x_limit_ = 0;
  clear_has_x_limit();
}
inline float SearchConstraint::x_limit() const {
  // @@protoc_insertion_point(field_get:roborts_decision.SearchConstraint.x_limit)
  return x_limit_;
}
inline void SearchConstraint::set_x_limit(float value) {
  set_has_x_limit();
  x_limit_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.SearchConstraint.x_limit)
}

// optional float y_limit = 2;
inline bool SearchConstraint::has_y_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchConstraint::set_has_y_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchConstraint::clear_has_y_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchConstraint::clear_y_limit() {
  y_limit_ = 0;
  clear_has_y_limit();
}
inline float SearchConstraint::y_limit() const {
  // @@protoc_insertion_point(field_get:roborts_decision.SearchConstraint.y_limit)
  return y_limit_;
}
inline void SearchConstraint::set_y_limit(float value) {
  set_has_y_limit();
  y_limit_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.SearchConstraint.y_limit)
}

// -------------------------------------------------------------------

// WhirlVel

// optional float angle_x_vel = 1;
inline bool WhirlVel::has_angle_x_vel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WhirlVel::set_has_angle_x_vel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WhirlVel::clear_has_angle_x_vel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WhirlVel::clear_angle_x_vel() {
  angle_x_vel_ = 0;
  clear_has_angle_x_vel();
}
inline float WhirlVel::angle_x_vel() const {
  // @@protoc_insertion_point(field_get:roborts_decision.WhirlVel.angle_x_vel)
  return angle_x_vel_;
}
inline void WhirlVel::set_angle_x_vel(float value) {
  set_has_angle_x_vel();
  angle_x_vel_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.WhirlVel.angle_x_vel)
}

// optional float angle_y_vel = 2;
inline bool WhirlVel::has_angle_y_vel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WhirlVel::set_has_angle_y_vel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WhirlVel::clear_has_angle_y_vel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WhirlVel::clear_angle_y_vel() {
  angle_y_vel_ = 0;
  clear_has_angle_y_vel();
}
inline float WhirlVel::angle_y_vel() const {
  // @@protoc_insertion_point(field_get:roborts_decision.WhirlVel.angle_y_vel)
  return angle_y_vel_;
}
inline void WhirlVel::set_angle_y_vel(float value) {
  set_has_angle_y_vel();
  angle_y_vel_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.WhirlVel.angle_y_vel)
}

// optional float angle_z_vel = 3;
inline bool WhirlVel::has_angle_z_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WhirlVel::set_has_angle_z_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WhirlVel::clear_has_angle_z_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WhirlVel::clear_angle_z_vel() {
  angle_z_vel_ = 0;
  clear_has_angle_z_vel();
}
inline float WhirlVel::angle_z_vel() const {
  // @@protoc_insertion_point(field_get:roborts_decision.WhirlVel.angle_z_vel)
  return angle_z_vel_;
}
inline void WhirlVel::set_angle_z_vel(float value) {
  set_has_angle_z_vel();
  angle_z_vel_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.WhirlVel.angle_z_vel)
}

// -------------------------------------------------------------------

// Referee

// optional string game_result = 2;
inline bool Referee::has_game_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Referee::set_has_game_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Referee::clear_has_game_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Referee::clear_game_result() {
  game_result_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_result();
}
inline const ::std::string& Referee::game_result() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.game_result)
  return game_result_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_game_result(const ::std::string& value) {
  set_has_game_result();
  game_result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.game_result)
}
inline void Referee::set_game_result(const char* value) {
  set_has_game_result();
  game_result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.game_result)
}
inline void Referee::set_game_result(const char* value, size_t size) {
  set_has_game_result();
  game_result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.game_result)
}
inline ::std::string* Referee::mutable_game_result() {
  set_has_game_result();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.game_result)
  return game_result_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_game_result() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.game_result)
  clear_has_game_result();
  return game_result_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_game_result(::std::string* game_result) {
  if (game_result != NULL) {
    set_has_game_result();
  } else {
    clear_has_game_result();
  }
  game_result_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_result);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.game_result)
}

// optional string game_status = 1;
inline bool Referee::has_game_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Referee::set_has_game_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Referee::clear_has_game_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Referee::clear_game_status() {
  game_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_status();
}
inline const ::std::string& Referee::game_status() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.game_status)
  return game_status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_game_status(const ::std::string& value) {
  set_has_game_status();
  game_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.game_status)
}
inline void Referee::set_game_status(const char* value) {
  set_has_game_status();
  game_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.game_status)
}
inline void Referee::set_game_status(const char* value, size_t size) {
  set_has_game_status();
  game_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.game_status)
}
inline ::std::string* Referee::mutable_game_status() {
  set_has_game_status();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.game_status)
  return game_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_game_status() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.game_status)
  clear_has_game_status();
  return game_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_game_status(::std::string* game_status) {
  if (game_status != NULL) {
    set_has_game_status();
  } else {
    clear_has_game_status();
  }
  game_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_status);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.game_status)
}

// optional string game_survivor = 3;
inline bool Referee::has_game_survivor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Referee::set_has_game_survivor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Referee::clear_has_game_survivor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Referee::clear_game_survivor() {
  game_survivor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_survivor();
}
inline const ::std::string& Referee::game_survivor() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.game_survivor)
  return game_survivor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_game_survivor(const ::std::string& value) {
  set_has_game_survivor();
  game_survivor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.game_survivor)
}
inline void Referee::set_game_survivor(const char* value) {
  set_has_game_survivor();
  game_survivor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.game_survivor)
}
inline void Referee::set_game_survivor(const char* value, size_t size) {
  set_has_game_survivor();
  game_survivor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.game_survivor)
}
inline ::std::string* Referee::mutable_game_survivor() {
  set_has_game_survivor();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.game_survivor)
  return game_survivor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_game_survivor() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.game_survivor)
  clear_has_game_survivor();
  return game_survivor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_game_survivor(::std::string* game_survivor) {
  if (game_survivor != NULL) {
    set_has_game_survivor();
  } else {
    clear_has_game_survivor();
  }
  game_survivor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_survivor);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.game_survivor)
}

// optional string robort_status = 4;
inline bool Referee::has_robort_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Referee::set_has_robort_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Referee::clear_has_robort_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Referee::clear_robort_status() {
  robort_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_robort_status();
}
inline const ::std::string& Referee::robort_status() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.robort_status)
  return robort_status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_robort_status(const ::std::string& value) {
  set_has_robort_status();
  robort_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.robort_status)
}
inline void Referee::set_robort_status(const char* value) {
  set_has_robort_status();
  robort_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.robort_status)
}
inline void Referee::set_robort_status(const char* value, size_t size) {
  set_has_robort_status();
  robort_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.robort_status)
}
inline ::std::string* Referee::mutable_robort_status() {
  set_has_robort_status();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.robort_status)
  return robort_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_robort_status() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.robort_status)
  clear_has_robort_status();
  return robort_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_robort_status(::std::string* robort_status) {
  if (robort_status != NULL) {
    set_has_robort_status();
  } else {
    clear_has_robort_status();
  }
  robort_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robort_status);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.robort_status)
}

// optional string robort_heat = 5;
inline bool Referee::has_robort_heat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Referee::set_has_robort_heat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Referee::clear_has_robort_heat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Referee::clear_robort_heat() {
  robort_heat_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_robort_heat();
}
inline const ::std::string& Referee::robort_heat() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.robort_heat)
  return robort_heat_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_robort_heat(const ::std::string& value) {
  set_has_robort_heat();
  robort_heat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.robort_heat)
}
inline void Referee::set_robort_heat(const char* value) {
  set_has_robort_heat();
  robort_heat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.robort_heat)
}
inline void Referee::set_robort_heat(const char* value, size_t size) {
  set_has_robort_heat();
  robort_heat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.robort_heat)
}
inline ::std::string* Referee::mutable_robort_heat() {
  set_has_robort_heat();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.robort_heat)
  return robort_heat_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_robort_heat() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.robort_heat)
  clear_has_robort_heat();
  return robort_heat_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_robort_heat(::std::string* robort_heat) {
  if (robort_heat != NULL) {
    set_has_robort_heat();
  } else {
    clear_has_robort_heat();
  }
  robort_heat_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robort_heat);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.robort_heat)
}

// optional string robort_bonus = 6;
inline bool Referee::has_robort_bonus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Referee::set_has_robort_bonus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Referee::clear_has_robort_bonus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Referee::clear_robort_bonus() {
  robort_bonus_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_robort_bonus();
}
inline const ::std::string& Referee::robort_bonus() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.robort_bonus)
  return robort_bonus_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_robort_bonus(const ::std::string& value) {
  set_has_robort_bonus();
  robort_bonus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.robort_bonus)
}
inline void Referee::set_robort_bonus(const char* value) {
  set_has_robort_bonus();
  robort_bonus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.robort_bonus)
}
inline void Referee::set_robort_bonus(const char* value, size_t size) {
  set_has_robort_bonus();
  robort_bonus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.robort_bonus)
}
inline ::std::string* Referee::mutable_robort_bonus() {
  set_has_robort_bonus();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.robort_bonus)
  return robort_bonus_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_robort_bonus() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.robort_bonus)
  clear_has_robort_bonus();
  return robort_bonus_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_robort_bonus(::std::string* robort_bonus) {
  if (robort_bonus != NULL) {
    set_has_robort_bonus();
  } else {
    clear_has_robort_bonus();
  }
  robort_bonus_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robort_bonus);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.robort_bonus)
}

// optional string robort_damage = 7;
inline bool Referee::has_robort_damage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Referee::set_has_robort_damage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Referee::clear_has_robort_damage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Referee::clear_robort_damage() {
  robort_damage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_robort_damage();
}
inline const ::std::string& Referee::robort_damage() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.robort_damage)
  return robort_damage_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_robort_damage(const ::std::string& value) {
  set_has_robort_damage();
  robort_damage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.robort_damage)
}
inline void Referee::set_robort_damage(const char* value) {
  set_has_robort_damage();
  robort_damage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.robort_damage)
}
inline void Referee::set_robort_damage(const char* value, size_t size) {
  set_has_robort_damage();
  robort_damage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.robort_damage)
}
inline ::std::string* Referee::mutable_robort_damage() {
  set_has_robort_damage();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.robort_damage)
  return robort_damage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_robort_damage() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.robort_damage)
  clear_has_robort_damage();
  return robort_damage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_robort_damage(::std::string* robort_damage) {
  if (robort_damage != NULL) {
    set_has_robort_damage();
  } else {
    clear_has_robort_damage();
  }
  robort_damage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robort_damage);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.robort_damage)
}

// optional string robort_shoot = 8;
inline bool Referee::has_robort_shoot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Referee::set_has_robort_shoot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Referee::clear_has_robort_shoot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Referee::clear_robort_shoot() {
  robort_shoot_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_robort_shoot();
}
inline const ::std::string& Referee::robort_shoot() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.robort_shoot)
  return robort_shoot_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_robort_shoot(const ::std::string& value) {
  set_has_robort_shoot();
  robort_shoot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.robort_shoot)
}
inline void Referee::set_robort_shoot(const char* value) {
  set_has_robort_shoot();
  robort_shoot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.robort_shoot)
}
inline void Referee::set_robort_shoot(const char* value, size_t size) {
  set_has_robort_shoot();
  robort_shoot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.robort_shoot)
}
inline ::std::string* Referee::mutable_robort_shoot() {
  set_has_robort_shoot();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.robort_shoot)
  return robort_shoot_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_robort_shoot() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.robort_shoot)
  clear_has_robort_shoot();
  return robort_shoot_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_robort_shoot(::std::string* robort_shoot) {
  if (robort_shoot != NULL) {
    set_has_robort_shoot();
  } else {
    clear_has_robort_shoot();
  }
  robort_shoot_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robort_shoot);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.robort_shoot)
}

// optional string bonus_status = 9;
inline bool Referee::has_bonus_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Referee::set_has_bonus_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Referee::clear_has_bonus_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Referee::clear_bonus_status() {
  bonus_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bonus_status();
}
inline const ::std::string& Referee::bonus_status() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.bonus_status)
  return bonus_status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_bonus_status(const ::std::string& value) {
  set_has_bonus_status();
  bonus_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.bonus_status)
}
inline void Referee::set_bonus_status(const char* value) {
  set_has_bonus_status();
  bonus_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.bonus_status)
}
inline void Referee::set_bonus_status(const char* value, size_t size) {
  set_has_bonus_status();
  bonus_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.bonus_status)
}
inline ::std::string* Referee::mutable_bonus_status() {
  set_has_bonus_status();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.bonus_status)
  return bonus_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_bonus_status() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.bonus_status)
  clear_has_bonus_status();
  return bonus_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_bonus_status(::std::string* bonus_status) {
  if (bonus_status != NULL) {
    set_has_bonus_status();
  } else {
    clear_has_bonus_status();
  }
  bonus_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bonus_status);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.bonus_status)
}

// optional string local_name = 10;
inline bool Referee::has_local_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Referee::set_has_local_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Referee::clear_has_local_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Referee::clear_local_name() {
  local_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_name();
}
inline const ::std::string& Referee::local_name() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.local_name)
  return local_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_local_name(const ::std::string& value) {
  set_has_local_name();
  local_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.local_name)
}
inline void Referee::set_local_name(const char* value) {
  set_has_local_name();
  local_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.local_name)
}
inline void Referee::set_local_name(const char* value, size_t size) {
  set_has_local_name();
  local_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.local_name)
}
inline ::std::string* Referee::mutable_local_name() {
  set_has_local_name();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.local_name)
  return local_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_local_name() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.local_name)
  clear_has_local_name();
  return local_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_local_name(::std::string* local_name) {
  if (local_name != NULL) {
    set_has_local_name();
  } else {
    clear_has_local_name();
  }
  local_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_name);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.local_name)
}

// optional string remote_name = 11;
inline bool Referee::has_remote_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Referee::set_has_remote_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Referee::clear_has_remote_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Referee::clear_remote_name() {
  remote_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_remote_name();
}
inline const ::std::string& Referee::remote_name() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Referee.remote_name)
  return remote_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_remote_name(const ::std::string& value) {
  set_has_remote_name();
  remote_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_decision.Referee.remote_name)
}
inline void Referee::set_remote_name(const char* value) {
  set_has_remote_name();
  remote_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_decision.Referee.remote_name)
}
inline void Referee::set_remote_name(const char* value, size_t size) {
  set_has_remote_name();
  remote_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.Referee.remote_name)
}
inline ::std::string* Referee::mutable_remote_name() {
  set_has_remote_name();
  // @@protoc_insertion_point(field_mutable:roborts_decision.Referee.remote_name)
  return remote_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Referee::release_remote_name() {
  // @@protoc_insertion_point(field_release:roborts_decision.Referee.remote_name)
  clear_has_remote_name();
  return remote_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Referee::set_allocated_remote_name(::std::string* remote_name) {
  if (remote_name != NULL) {
    set_has_remote_name();
  } else {
    clear_has_remote_name();
  }
  remote_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_name);
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Referee.remote_name)
}

// -------------------------------------------------------------------

// TopicName

// repeated string topic = 1;
inline int TopicName::topic_size() const {
  return topic_.size();
}
inline void TopicName::clear_topic() {
  topic_.Clear();
}
inline const ::std::string& TopicName::topic(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.TopicName.topic)
  return topic_.Get(index);
}
inline ::std::string* TopicName::mutable_topic(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_decision.TopicName.topic)
  return topic_.Mutable(index);
}
inline void TopicName::set_topic(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:roborts_decision.TopicName.topic)
  topic_.Mutable(index)->assign(value);
}
inline void TopicName::set_topic(int index, const char* value) {
  topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:roborts_decision.TopicName.topic)
}
inline void TopicName::set_topic(int index, const char* value, size_t size) {
  topic_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:roborts_decision.TopicName.topic)
}
inline ::std::string* TopicName::add_topic() {
  // @@protoc_insertion_point(field_add_mutable:roborts_decision.TopicName.topic)
  return topic_.Add();
}
inline void TopicName::add_topic(const ::std::string& value) {
  topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:roborts_decision.TopicName.topic)
}
inline void TopicName::add_topic(const char* value) {
  topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:roborts_decision.TopicName.topic)
}
inline void TopicName::add_topic(const char* value, size_t size) {
  topic_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:roborts_decision.TopicName.topic)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TopicName::topic() const {
  // @@protoc_insertion_point(field_list:roborts_decision.TopicName.topic)
  return topic_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TopicName::mutable_topic() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.TopicName.topic)
  return &topic_;
}

// -------------------------------------------------------------------

// DecisionConfig

// repeated .roborts_decision.Point point = 1;
inline int DecisionConfig::point_size() const {
  return point_.size();
}
inline void DecisionConfig::clear_point() {
  point_.Clear();
}
inline const ::roborts_decision::Point& DecisionConfig::point(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.point)
  return point_.Get(index);
}
inline ::roborts_decision::Point* DecisionConfig::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.point)
  return point_.Mutable(index);
}
inline ::roborts_decision::Point* DecisionConfig::add_point() {
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.point)
  return point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
DecisionConfig::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.point)
  return &point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
DecisionConfig::point() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.point)
  return point_;
}

// optional bool simulate = 2 [default = false];
inline bool DecisionConfig::has_simulate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecisionConfig::set_has_simulate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecisionConfig::clear_has_simulate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecisionConfig::clear_simulate() {
  simulate_ = false;
  clear_has_simulate();
}
inline bool DecisionConfig::simulate() const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.simulate)
  return simulate_;
}
inline void DecisionConfig::set_simulate(bool value) {
  set_has_simulate();
  simulate_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.DecisionConfig.simulate)
}

// optional bool master = 3 [default = false];
inline bool DecisionConfig::has_master() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecisionConfig::set_has_master() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DecisionConfig::clear_has_master() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DecisionConfig::clear_master() {
  master_ = false;
  clear_has_master();
}
inline bool DecisionConfig::master() const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.master)
  return master_;
}
inline void DecisionConfig::set_master(bool value) {
  set_has_master();
  master_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.DecisionConfig.master)
}

// repeated .roborts_decision.Point escape = 4;
inline int DecisionConfig::escape_size() const {
  return escape_.size();
}
inline void DecisionConfig::clear_escape() {
  escape_.Clear();
}
inline const ::roborts_decision::Point& DecisionConfig::escape(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.escape)
  return escape_.Get(index);
}
inline ::roborts_decision::Point* DecisionConfig::mutable_escape(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.escape)
  return escape_.Mutable(index);
}
inline ::roborts_decision::Point* DecisionConfig::add_escape() {
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.escape)
  return escape_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
DecisionConfig::mutable_escape() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.escape)
  return &escape_;
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
DecisionConfig::escape() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.escape)
  return escape_;
}

// repeated .roborts_decision.Point buff_point = 5;
inline int DecisionConfig::buff_point_size() const {
  return buff_point_.size();
}
inline void DecisionConfig::clear_buff_point() {
  buff_point_.Clear();
}
inline const ::roborts_decision::Point& DecisionConfig::buff_point(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.buff_point)
  return buff_point_.Get(index);
}
inline ::roborts_decision::Point* DecisionConfig::mutable_buff_point(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.buff_point)
  return buff_point_.Mutable(index);
}
inline ::roborts_decision::Point* DecisionConfig::add_buff_point() {
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.buff_point)
  return buff_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
DecisionConfig::mutable_buff_point() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.buff_point)
  return &buff_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
DecisionConfig::buff_point() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.buff_point)
  return buff_point_;
}

// repeated .roborts_decision.Point search_path = 6;
inline int DecisionConfig::search_path_size() const {
  return search_path_.size();
}
inline void DecisionConfig::clear_search_path() {
  search_path_.Clear();
}
inline const ::roborts_decision::Point& DecisionConfig::search_path(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.search_path)
  return search_path_.Get(index);
}
inline ::roborts_decision::Point* DecisionConfig::mutable_search_path(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.search_path)
  return search_path_.Mutable(index);
}
inline ::roborts_decision::Point* DecisionConfig::add_search_path() {
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.search_path)
  return search_path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
DecisionConfig::mutable_search_path() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.search_path)
  return &search_path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
DecisionConfig::search_path() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.search_path)
  return search_path_;
}

// repeated .roborts_decision.Point e_search_path = 7;
inline int DecisionConfig::e_search_path_size() const {
  return e_search_path_.size();
}
inline void DecisionConfig::clear_e_search_path() {
  e_search_path_.Clear();
}
inline const ::roborts_decision::Point& DecisionConfig::e_search_path(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.e_search_path)
  return e_search_path_.Get(index);
}
inline ::roborts_decision::Point* DecisionConfig::mutable_e_search_path(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.e_search_path)
  return e_search_path_.Mutable(index);
}
inline ::roborts_decision::Point* DecisionConfig::add_e_search_path() {
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.e_search_path)
  return e_search_path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
DecisionConfig::mutable_e_search_path() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.e_search_path)
  return &e_search_path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
DecisionConfig::e_search_path() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.e_search_path)
  return e_search_path_;
}

// repeated .roborts_decision.Point c_search_path = 8;
inline int DecisionConfig::c_search_path_size() const {
  return c_search_path_.size();
}
inline void DecisionConfig::clear_c_search_path() {
  c_search_path_.Clear();
}
inline const ::roborts_decision::Point& DecisionConfig::c_search_path(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.c_search_path)
  return c_search_path_.Get(index);
}
inline ::roborts_decision::Point* DecisionConfig::mutable_c_search_path(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.c_search_path)
  return c_search_path_.Mutable(index);
}
inline ::roborts_decision::Point* DecisionConfig::add_c_search_path() {
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.c_search_path)
  return c_search_path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
DecisionConfig::mutable_c_search_path() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.c_search_path)
  return &c_search_path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
DecisionConfig::c_search_path() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.c_search_path)
  return c_search_path_;
}

// optional .roborts_decision.WhirlVel whirl_vel = 9;
inline bool DecisionConfig::has_whirl_vel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DecisionConfig::set_has_whirl_vel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DecisionConfig::clear_has_whirl_vel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DecisionConfig::clear_whirl_vel() {
  if (whirl_vel_ != NULL) whirl_vel_->::roborts_decision::WhirlVel::Clear();
  clear_has_whirl_vel();
}
inline const ::roborts_decision::WhirlVel& DecisionConfig::whirl_vel() const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.whirl_vel)
  return whirl_vel_ != NULL ? *whirl_vel_ : *default_instance_->whirl_vel_;
}
inline ::roborts_decision::WhirlVel* DecisionConfig::mutable_whirl_vel() {
  set_has_whirl_vel();
  if (whirl_vel_ == NULL) {
    whirl_vel_ = new ::roborts_decision::WhirlVel;
  }
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.whirl_vel)
  return whirl_vel_;
}
inline ::roborts_decision::WhirlVel* DecisionConfig::release_whirl_vel() {
  // @@protoc_insertion_point(field_release:roborts_decision.DecisionConfig.whirl_vel)
  clear_has_whirl_vel();
  ::roborts_decision::WhirlVel* temp = whirl_vel_;
  whirl_vel_ = NULL;
  return temp;
}
inline void DecisionConfig::set_allocated_whirl_vel(::roborts_decision::WhirlVel* whirl_vel) {
  delete whirl_vel_;
  whirl_vel_ = whirl_vel;
  if (whirl_vel) {
    set_has_whirl_vel();
  } else {
    clear_has_whirl_vel();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.DecisionConfig.whirl_vel)
}

// repeated .roborts_decision.Point auxe_bot = 10;
inline int DecisionConfig::auxe_bot_size() const {
  return auxe_bot_.size();
}
inline void DecisionConfig::clear_auxe_bot() {
  auxe_bot_.Clear();
}
inline const ::roborts_decision::Point& DecisionConfig::auxe_bot(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.auxe_bot)
  return auxe_bot_.Get(index);
}
inline ::roborts_decision::Point* DecisionConfig::mutable_auxe_bot(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.auxe_bot)
  return auxe_bot_.Mutable(index);
}
inline ::roborts_decision::Point* DecisionConfig::add_auxe_bot() {
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.auxe_bot)
  return auxe_bot_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
DecisionConfig::mutable_auxe_bot() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.auxe_bot)
  return &auxe_bot_;
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
DecisionConfig::auxe_bot() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.auxe_bot)
  return auxe_bot_;
}

// repeated .roborts_decision.Point master_bot = 11;
inline int DecisionConfig::master_bot_size() const {
  return master_bot_.size();
}
inline void DecisionConfig::clear_master_bot() {
  master_bot_.Clear();
}
inline const ::roborts_decision::Point& DecisionConfig::master_bot(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.master_bot)
  return master_bot_.Get(index);
}
inline ::roborts_decision::Point* DecisionConfig::mutable_master_bot(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.master_bot)
  return master_bot_.Mutable(index);
}
inline ::roborts_decision::Point* DecisionConfig::add_master_bot() {
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.master_bot)
  return master_bot_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
DecisionConfig::mutable_master_bot() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.master_bot)
  return &master_bot_;
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
DecisionConfig::master_bot() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.master_bot)
  return master_bot_;
}

// optional .roborts_decision.Point wing_bot_task_point = 12;
inline bool DecisionConfig::has_wing_bot_task_point() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DecisionConfig::set_has_wing_bot_task_point() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DecisionConfig::clear_has_wing_bot_task_point() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DecisionConfig::clear_wing_bot_task_point() {
  if (wing_bot_task_point_ != NULL) wing_bot_task_point_->::roborts_decision::Point::Clear();
  clear_has_wing_bot_task_point();
}
inline const ::roborts_decision::Point& DecisionConfig::wing_bot_task_point() const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.wing_bot_task_point)
  return wing_bot_task_point_ != NULL ? *wing_bot_task_point_ : *default_instance_->wing_bot_task_point_;
}
inline ::roborts_decision::Point* DecisionConfig::mutable_wing_bot_task_point() {
  set_has_wing_bot_task_point();
  if (wing_bot_task_point_ == NULL) {
    wing_bot_task_point_ = new ::roborts_decision::Point;
  }
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.wing_bot_task_point)
  return wing_bot_task_point_;
}
inline ::roborts_decision::Point* DecisionConfig::release_wing_bot_task_point() {
  // @@protoc_insertion_point(field_release:roborts_decision.DecisionConfig.wing_bot_task_point)
  clear_has_wing_bot_task_point();
  ::roborts_decision::Point* temp = wing_bot_task_point_;
  wing_bot_task_point_ = NULL;
  return temp;
}
inline void DecisionConfig::set_allocated_wing_bot_task_point(::roborts_decision::Point* wing_bot_task_point) {
  delete wing_bot_task_point_;
  wing_bot_task_point_ = wing_bot_task_point;
  if (wing_bot_task_point) {
    set_has_wing_bot_task_point();
  } else {
    clear_has_wing_bot_task_point();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.DecisionConfig.wing_bot_task_point)
}

// repeated .roborts_decision.Point wait_point = 13;
inline int DecisionConfig::wait_point_size() const {
  return wait_point_.size();
}
inline void DecisionConfig::clear_wait_point() {
  wait_point_.Clear();
}
inline const ::roborts_decision::Point& DecisionConfig::wait_point(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.wait_point)
  return wait_point_.Get(index);
}
inline ::roborts_decision::Point* DecisionConfig::mutable_wait_point(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_decision.DecisionConfig.wait_point)
  return wait_point_.Mutable(index);
}
inline ::roborts_decision::Point* DecisionConfig::add_wait_point() {
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.wait_point)
  return wait_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >*
DecisionConfig::mutable_wait_point() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.wait_point)
  return &wait_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_decision::Point >&
DecisionConfig::wait_point() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.wait_point)
  return wait_point_;
}

// repeated float square_x = 14;
inline int DecisionConfig::square_x_size() const {
  return square_x_.size();
}
inline void DecisionConfig::clear_square_x() {
  square_x_.Clear();
}
inline float DecisionConfig::square_x(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.square_x)
  return square_x_.Get(index);
}
inline void DecisionConfig::set_square_x(int index, float value) {
  square_x_.Set(index, value);
  // @@protoc_insertion_point(field_set:roborts_decision.DecisionConfig.square_x)
}
inline void DecisionConfig::add_square_x(float value) {
  square_x_.Add(value);
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.square_x)
}
inline const ::google::protobuf::RepeatedField< float >&
DecisionConfig::square_x() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.square_x)
  return square_x_;
}
inline ::google::protobuf::RepeatedField< float >*
DecisionConfig::mutable_square_x() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.square_x)
  return &square_x_;
}

// repeated float square_y = 15;
inline int DecisionConfig::square_y_size() const {
  return square_y_.size();
}
inline void DecisionConfig::clear_square_y() {
  square_y_.Clear();
}
inline float DecisionConfig::square_y(int index) const {
  // @@protoc_insertion_point(field_get:roborts_decision.DecisionConfig.square_y)
  return square_y_.Get(index);
}
inline void DecisionConfig::set_square_y(int index, float value) {
  square_y_.Set(index, value);
  // @@protoc_insertion_point(field_set:roborts_decision.DecisionConfig.square_y)
}
inline void DecisionConfig::add_square_y(float value) {
  square_y_.Add(value);
  // @@protoc_insertion_point(field_add:roborts_decision.DecisionConfig.square_y)
}
inline const ::google::protobuf::RepeatedField< float >&
DecisionConfig::square_y() const {
  // @@protoc_insertion_point(field_list:roborts_decision.DecisionConfig.square_y)
  return square_y_;
}
inline ::google::protobuf::RepeatedField< float >*
DecisionConfig::mutable_square_y() {
  // @@protoc_insertion_point(field_mutable_list:roborts_decision.DecisionConfig.square_y)
  return &square_y_;
}

// -------------------------------------------------------------------

// RobotInfo

// optional int32 hp = 1;
inline bool RobotInfo::has_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotInfo::set_has_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotInfo::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 RobotInfo::hp() const {
  // @@protoc_insertion_point(field_get:roborts_decision.RobotInfo.hp)
  return hp_;
}
inline void RobotInfo::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.RobotInfo.hp)
}

// optional int32 heat = 2;
inline bool RobotInfo::has_heat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotInfo::set_has_heat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotInfo::clear_has_heat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotInfo::clear_heat() {
  heat_ = 0;
  clear_has_heat();
}
inline ::google::protobuf::int32 RobotInfo::heat() const {
  // @@protoc_insertion_point(field_get:roborts_decision.RobotInfo.heat)
  return heat_;
}
inline void RobotInfo::set_heat(::google::protobuf::int32 value) {
  set_has_heat();
  heat_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.RobotInfo.heat)
}

// optional int32 bullets = 3;
inline bool RobotInfo::has_bullets() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotInfo::set_has_bullets() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotInfo::clear_has_bullets() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotInfo::clear_bullets() {
  bullets_ = 0;
  clear_has_bullets();
}
inline ::google::protobuf::int32 RobotInfo::bullets() const {
  // @@protoc_insertion_point(field_get:roborts_decision.RobotInfo.bullets)
  return bullets_;
}
inline void RobotInfo::set_bullets(::google::protobuf::int32 value) {
  set_has_bullets();
  bullets_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.RobotInfo.bullets)
}

// -------------------------------------------------------------------

// PunishInfo

// optional bool on_gimbal = 1;
inline bool PunishInfo::has_on_gimbal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PunishInfo::set_has_on_gimbal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PunishInfo::clear_has_on_gimbal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PunishInfo::clear_on_gimbal() {
  on_gimbal_ = false;
  clear_has_on_gimbal();
}
inline bool PunishInfo::on_gimbal() const {
  // @@protoc_insertion_point(field_get:roborts_decision.PunishInfo.on_gimbal)
  return on_gimbal_;
}
inline void PunishInfo::set_on_gimbal(bool value) {
  set_has_on_gimbal();
  on_gimbal_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.PunishInfo.on_gimbal)
}

// optional bool on_chassis = 2;
inline bool PunishInfo::has_on_chassis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PunishInfo::set_has_on_chassis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PunishInfo::clear_has_on_chassis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PunishInfo::clear_on_chassis() {
  on_chassis_ = false;
  clear_has_on_chassis();
}
inline bool PunishInfo::on_chassis() const {
  // @@protoc_insertion_point(field_get:roborts_decision.PunishInfo.on_chassis)
  return on_chassis_;
}
inline void PunishInfo::set_on_chassis(bool value) {
  set_has_on_chassis();
  on_chassis_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.PunishInfo.on_chassis)
}

// -------------------------------------------------------------------

// Status

// required bool is_running = 1;
inline bool Status::has_is_running() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_is_running() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_is_running() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_is_running() {
  is_running_ = false;
  clear_has_is_running();
}
inline bool Status::is_running() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Status.is_running)
  return is_running_;
}
inline void Status::set_is_running(bool value) {
  set_has_is_running();
  is_running_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.Status.is_running)
}

// optional .roborts_decision.Status.RunStatus status = 2;
inline bool Status::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::roborts_decision::Status_RunStatus Status::status() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Status.status)
  return static_cast< ::roborts_decision::Status_RunStatus >(status_);
}
inline void Status::set_status(::roborts_decision::Status_RunStatus value) {
  assert(::roborts_decision::Status_RunStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:roborts_decision.Status.status)
}

// optional .roborts_decision.Point position = 3;
inline bool Status::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Status::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Status::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Status::clear_position() {
  if (position_ != NULL) position_->::roborts_decision::Point::Clear();
  clear_has_position();
}
inline const ::roborts_decision::Point& Status::position() const {
  // @@protoc_insertion_point(field_get:roborts_decision.Status.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::roborts_decision::Point* Status::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::roborts_decision::Point;
  }
  // @@protoc_insertion_point(field_mutable:roborts_decision.Status.position)
  return position_;
}
inline ::roborts_decision::Point* Status::release_position() {
  // @@protoc_insertion_point(field_release:roborts_decision.Status.position)
  clear_has_position();
  ::roborts_decision::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Status::set_allocated_position(::roborts_decision::Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.Status.position)
}

// -------------------------------------------------------------------

// MutualInfo

// optional .roborts_decision.RobotInfo robort_info = 1;
inline bool MutualInfo::has_robort_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutualInfo::set_has_robort_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MutualInfo::clear_has_robort_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MutualInfo::clear_robort_info() {
  if (robort_info_ != NULL) robort_info_->::roborts_decision::RobotInfo::Clear();
  clear_has_robort_info();
}
inline const ::roborts_decision::RobotInfo& MutualInfo::robort_info() const {
  // @@protoc_insertion_point(field_get:roborts_decision.MutualInfo.robort_info)
  return robort_info_ != NULL ? *robort_info_ : *default_instance_->robort_info_;
}
inline ::roborts_decision::RobotInfo* MutualInfo::mutable_robort_info() {
  set_has_robort_info();
  if (robort_info_ == NULL) {
    robort_info_ = new ::roborts_decision::RobotInfo;
  }
  // @@protoc_insertion_point(field_mutable:roborts_decision.MutualInfo.robort_info)
  return robort_info_;
}
inline ::roborts_decision::RobotInfo* MutualInfo::release_robort_info() {
  // @@protoc_insertion_point(field_release:roborts_decision.MutualInfo.robort_info)
  clear_has_robort_info();
  ::roborts_decision::RobotInfo* temp = robort_info_;
  robort_info_ = NULL;
  return temp;
}
inline void MutualInfo::set_allocated_robort_info(::roborts_decision::RobotInfo* robort_info) {
  delete robort_info_;
  robort_info_ = robort_info;
  if (robort_info) {
    set_has_robort_info();
  } else {
    clear_has_robort_info();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.MutualInfo.robort_info)
}

// optional .roborts_decision.PunishInfo punish = 2;
inline bool MutualInfo::has_punish() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MutualInfo::set_has_punish() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MutualInfo::clear_has_punish() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MutualInfo::clear_punish() {
  if (punish_ != NULL) punish_->::roborts_decision::PunishInfo::Clear();
  clear_has_punish();
}
inline const ::roborts_decision::PunishInfo& MutualInfo::punish() const {
  // @@protoc_insertion_point(field_get:roborts_decision.MutualInfo.punish)
  return punish_ != NULL ? *punish_ : *default_instance_->punish_;
}
inline ::roborts_decision::PunishInfo* MutualInfo::mutable_punish() {
  set_has_punish();
  if (punish_ == NULL) {
    punish_ = new ::roborts_decision::PunishInfo;
  }
  // @@protoc_insertion_point(field_mutable:roborts_decision.MutualInfo.punish)
  return punish_;
}
inline ::roborts_decision::PunishInfo* MutualInfo::release_punish() {
  // @@protoc_insertion_point(field_release:roborts_decision.MutualInfo.punish)
  clear_has_punish();
  ::roborts_decision::PunishInfo* temp = punish_;
  punish_ = NULL;
  return temp;
}
inline void MutualInfo::set_allocated_punish(::roborts_decision::PunishInfo* punish) {
  delete punish_;
  punish_ = punish;
  if (punish) {
    set_has_punish();
  } else {
    clear_has_punish();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.MutualInfo.punish)
}

// optional .roborts_decision.Status status = 3;
inline bool MutualInfo::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MutualInfo::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MutualInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MutualInfo::clear_status() {
  if (status_ != NULL) status_->::roborts_decision::Status::Clear();
  clear_has_status();
}
inline const ::roborts_decision::Status& MutualInfo::status() const {
  // @@protoc_insertion_point(field_get:roborts_decision.MutualInfo.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::roborts_decision::Status* MutualInfo::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::roborts_decision::Status;
  }
  // @@protoc_insertion_point(field_mutable:roborts_decision.MutualInfo.status)
  return status_;
}
inline ::roborts_decision::Status* MutualInfo::release_status() {
  // @@protoc_insertion_point(field_release:roborts_decision.MutualInfo.status)
  clear_has_status();
  ::roborts_decision::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline void MutualInfo::set_allocated_status(::roborts_decision::Status* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_decision.MutualInfo.status)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace roborts_decision

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::roborts_decision::Status_RunStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::roborts_decision::Status_RunStatus>() {
  return ::roborts_decision::Status_RunStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_decision_2eproto__INCLUDED
